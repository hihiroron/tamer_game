import 'package:flutter/material.dart';
import 'package:bonfire/bonfire.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tamer_game/common/list/monster_map.dart';
import 'package:tamer_game/common/models/monster.dart';
import 'package:tamer_game/decorations/battle/bar_life_controller.dart';
import 'package:tamer_game/decorations/battle/bar_life_widget.dart';
import 'package:tamer_game/decorations/battle/battle_map_deco_controller.dart';
import 'package:tamer_game/decorations/battle/battle_monster_field.dart';
import 'package:tamer_game/decorations/battle/battle_monster_preparation.dart';
import 'package:tamer_game/decorations/battle/battle_player.dart';
import 'package:tamer_game/decorations/battle/battle_player_monster.dart';
import 'package:tamer_game/decorations/battle/battle_rival.dart';
import 'package:tamer_game/decorations/battle/knight_interface.dart';
import 'package:tamer_game/util/multi_menu.dart';
import 'package:tamer_game/map/controller/battle_map_controller.dart';
import 'package:tamer_game/map/state/battle_map_state.dart';
import 'package:tamer_game/map/view/home_map.dart';
import 'package:tamer_game/util/extension.dart';
import 'package:tamer_game/util/single_menu.dart';
import 'package:flutter_animate/flutter_animate.dart';

class BattleMap extends ConsumerStatefulWidget {
  const BattleMap({Key? key}) : super(key: key);

  @override
  BattleMapSt createState() => BattleMapSt();
}

class BattleMapSt extends ConsumerState<BattleMap> {
  static double tileSize = 40.0; // „Çø„Ç§„É´„ÅÆ„Çµ„Ç§„Ç∫ÂÆöÁæ©
  // „É¢„É≥„Çπ„Çø„ÉºÁä∂Ê≥Å
  static bool field1 = false;

  @override
  void initState() {
    // BonfireWidget„Å´gameController„Ç™„Éó„Ç∑„Éß„É≥„ÇÇËÄÉÊÖÆ
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      TalkDialog.show(
        context,
        [
          Say(
            text: [const TextSpan(text: 'Êà¶ÈóòÈñãÂßãÔºÅ')],
          ),
        ],
        style: Theme.of(context)
            .textTheme
            .titleLarge!
            .copyWith(color: Colors.white),
      );
    });
    // BonfireInjector().put((i) => BarLifeController());
    BonfireInjector().put((i) => BattleMapDecoController());
  }

  @override
  Widget build(BuildContext context) {
    // „Ç≤„Éº„É†ÁîªÈù¢Widget
    // final a = ref.watch();
    ref.listen<AsyncValue<BattleMapState?>>(
        battleMapControllerProvider, (prev, next) {});
    final state = ref.watch(battleMapControllerProvider);
    // Êõ∏„ÅçËæº„ÅøÁî®
    final controller = ref.watch(battleMapControllerProvider.notifier);
    return state.when(
      data: (data) {
        return Scaffold(
          body: Stack(
            children: <Widget>[
              BonfireWidget(
                showCollisionArea: false, // ÂΩì„Åü„ÇäÂà§ÂÆö„ÅÆÂèØË¶ñÂåñ
                // „Éû„ÉÉ„ÉóÁî®json„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
                map: WorldMapByTiled(
                  'maps/forestBackGround.json',
                  forceTileSize: Vector2(tileSize, tileSize),
                  objectsBuilder: {},
                ),
                decorations: decorations(data, controller),
                // „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Åó„ÅãËøΩÂä†„Åß„Åç„Çì
                // onReady: (game) {
                //   _addField(game, data);
                // },
                // „Ç´„É°„É©Ë®≠ÂÆö
                // overlayBuilderMap: {
                //   'barLife': (context, game) => const BarLifeWidget(
                //         left: 30,
                //         top: 110,
                //       ),
                //   'barLife2': (context, game) => const BarLifeWidget(
                //         left: 290,
                //         top: 560,
                //       ),
                // },
                // initialActiveOverlays: const [
                //   'barLife',
                //   'barLife2',
                // ],
                interface: MasterInterface(),
                cameraConfig: CameraConfig(
                  moveOnlyMapArea: true,
                  sizeMovementWindow: Vector2.zero(),
                  smoothCameraEnabled: true,
                  smoothCameraSpeed: 10,
                ),
                // „Ç®„É©„Éº„Å´„Å™„Çã
                // overlayBuilderMap: TalkDialog.show(
                //   context,
                //   [
                //     Say(
                //       text: [const TextSpan(text: 'Êà¶ÈóòÈñãÂßãÔºÅ')], // Ë°®Á§∫„Åô„Çã„ÉÜ„Ç≠„Çπ„Éà
                //     ),
                //     Say(
                //       text: [const TextSpan(text: 'Êà¶Èóò‰∏≠„Éª„Éª„Éª')], // Ë°®Á§∫„Åô„Çã„ÉÜ
                //     ), // Ë°®Á§∫„Åô„Çã„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                //   ],
                //   style: Theme.of(context)
                //       .textTheme
                //       .titleLarge!
                //       .copyWith(color: Colors.white),
                // ),
                // ÁµêÂ±Ä„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„Åó„ÅãËøΩÂä†„Åß„Åç„Çì
                // interface: GameInterface(),
                // „É≠„Éº„Éâ‰∏≠„ÅÆÁîªÈù¢„ÅÆË®≠ÂÆö
                progress: Container(
                  width: double.maxFinite,
                  height: double.maxFinite,
                  color: Colors.black,
                ),
              ),
              Container(
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.white, width: 2),
                ),
                width: double.infinity,
                height: 100,
                // margin: const EdgeInsets.all(3),
                // color: Colors.pink,
                child: Stack(
                  children: [
                    Align(
                      alignment: Alignment.bottomLeft,
                      child: Text(
                        '„Çø„Éº„É≥Ôºö${data.turnNum.toString()}',
                        style: TextStyle(
                          backgroundColor: Colors.white,
                          fontWeight: FontWeight.bold,
                          fontSize: 18,
                          color: Colors.black,
                        ),
                      ),
                    ),
                    Align(
                      alignment: Alignment.bottomCenter,
                      child: Text(
                        'Áõ∏ÊâãÊâãÊú≠Ôºö${data.handCardsRival.length}',
                        style: TextStyle(
                          backgroundColor: Colors.white,
                          fontWeight: FontWeight.bold,
                          fontSize: 18,
                          color: Colors.black,
                        ),
                      ),
                    ),
                    Align(
                      alignment: Alignment.bottomRight,
                      child: Text(
                        'Ë°åÂãï‰∏≠Ôºö${data.isPlayerTurn ? 'Ëá™ÂàÜ' : 'Áõ∏Êâã'}',
                        style: TextStyle(
                          backgroundColor: Colors.white,
                          fontWeight: FontWeight.bold,
                          fontSize: 18,
                          color: Colors.black,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              // Center(
              //   child: Text(
              //     state.value!.fieldInfos[2]!.fieldStatus.name +
              //         "  ~   " +
              //         data.fieldInfos[2]!.fieldNumber.toString() +
              //         " : " +
              //         data.fieldInfos[2]!.fieldStatus.name +
              //         'turnNum' +
              //         data.turnNum.toString(),
              //     style: TextStyle(
              //       backgroundColor: Colors.white,
              //       fontWeight: FontWeight.bold,
              //       fontSize: 10,
              //       color: Colors.black,
              //     ),
              //   ),
              // ),
              Stack(
                children: _addField(data, controller),
              ),
              Align(
                alignment: Alignment(-0.80, -0.60),
                child: Text(
                  'üíô: ${data.hitPointRival}/5',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 18,
                    color: Colors.white,
                  ),
                ),
              ),

              Align(
                alignment: Alignment(0.75, 0.57),
                child: Text(
                  '‚ù§Ô∏è: ${data.hitPointPlayer}/5',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 18,
                    color: Colors.white,
                  ),
                ),
              ),
              ElevatedButton(
                onPressed: () {
                  context.goTo(const HomeMap());
                  // List<Monster>? list = data.monstersOfHandCards;
                  // list.removeRange(0, 1);
                  // state = AsyncData(data.copyWith(monstersOfHandCards: list));
                },
                child: Text('„Éû„ÉÉ„ÉóÁîªÈù¢„Å∏'),
              ),
              // „Çø„Éº„É≥Êï∞Ë°®Á§∫
              Align(
                alignment: Alignment(0.85, -0.50),
                child: Text(data.turnNum.toString()),
              ),
              Align(
                alignment: Alignment.bottomCenter,
                child: Container(
                  // decoration: BoxDecoration(
                  //   border: Border.all(color: Colors.white, width: 2),
                  // ),
                  width: double.infinity,
                  height: 120,
                  margin: const EdgeInsets.fromLTRB(8, 0, 8, 15),
                  padding: const EdgeInsets.fromLTRB(0, 15, 0, 0),
                  // margin: const EdgeInsets.all(3),
                  // color: Colors.pink,
                  child: Container(
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: Colors.white,
                      ),
                    ),
                    child: Scaffold(
                      backgroundColor: Colors.blueGrey,
                      body: Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: _getCardList(controller, data),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
      loading: () => const Center(
        child: CircularProgressIndicator(
          backgroundColor: Colors.black,
          color: Colors.black,
        ),
      ),
      error: (e, _) => Dialog(
        child: Text(
          "„Ç®„É©„Éº„Åß„Åô\n$e",
          style: const TextStyle(fontSize: 18),
        ),
        backgroundColor: Colors.blueGrey,
      ),
    );
  }

  List<Widget> dialogOptionMonsterAttackField({
    required Map<int, String> location,
    required BattleMapState data,
    required int fieldNumMe,
    required int monsterIdMe,
    required BattleMapController controller,
    required String attackRange,
  }) {
    // ÊîªÊíÉ„Åô„ÇãÁõ∏Êâã„Éï„Ç£„Éº„É´„Éâ„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
    final List<Widget> itemListRivalMonster = [];
    // rangeÂ§ñÊ∂à„Åó„Åü„Çà„Éï„É©„Ç∞
    bool isDeleteChoice = false;
    // Áõ∏Êâã„Éï„Ç£„Éº„É´„ÉâÔºî„Å§„ÅÆ„É´„Éº„Éó
    for (final fieldInfo in data.fieldInfos.sublist(4, 8)) {
      // „É¢„É≥„Çπ„Çø„Éº„Åå„ÅÑ„Çã„Éï„Ç£„Éº„É´„Éâ„ÅÆ„Åø„É°„Éã„É•„Éº„Å´Ë°®Á§∫
      if (fieldInfo!.fieldStatus == FieldStatus.monsterSummon ||
          fieldInfo.fieldStatus == FieldStatus.monsterAlreadyActed) {
        if (controller.isAttackRange(
          isPlayer: true,
          fieldNum1: fieldNumMe,
          fieldNum2: fieldInfo.fieldNumber,
          attackRange: attackRange,
        )) {
          itemListRivalMonster.insert(
            0,
            SimpleDialogOption(
              child: Text(
                "${location[fieldInfo.fieldNumber]}",
                style: const TextStyle(
                  fontSize: 20,
                  color: Colors.white,
                ),
              ),
              onPressed: () async {
                // ÔºíÁîªÈù¢Êàª„Çã
                int count = 0;
                Navigator.popUntil(context, (_) => count++ >= 2);
                await controller.attackMonster(
                  isPlayer: true,
                  fNumber1: fieldNumMe,
                  fNumber2: fieldInfo.fieldNumber,
                  hitPoint2: fieldInfo.hitPoint!,
                  power: data.monsters
                      .firstWhere((e) => e.id == monsterIdMe)
                      .skill1['power'],
                );
              },
            ),
          );
        } else {
          isDeleteChoice = true;
        }
      }
    }
    if (itemListRivalMonster.isEmpty && !isDeleteChoice) {
      // Áõ¥Êé•ÊîªÊíÉ
      itemListRivalMonster.insert(
        0,
        SimpleDialogOption(
          child: const Text(
            "Áõ∏Êâã„Éó„É¨„Ç§„É§„Éº",
            style: TextStyle(
              fontSize: 20,
              color: Colors.white,
            ),
          ),
          onPressed: () async {
            // ÔºíÁîªÈù¢Êàª„Çã
            int count = 0;
            Navigator.popUntil(context, (_) => count++ >= 2);
            await controller.attackDirect(
              isPlayer: true,
              fNumberMe: fieldNumMe,
              hitPointMaster: data.hitPointRival,
              power: data.monsters
                  .firstWhere((e) => e.id == monsterIdMe)
                  .skill1['power'],
            );
          },
        ),
      );
    }
    return itemListRivalMonster;
  }

  SimpleDialogOption dialogOptionMonsterAttack({
    required String skillName,
    required List<Widget> itemList,
  }) {
    return SimpleDialogOption(
      child: Text(
        skillName,
        style: const TextStyle(
          fontSize: 20,
          color: Colors.white,
        ),
      ),
      onPressed: () {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return MultiMenu(
              title: const Text(
                "ÊîªÊíÉ„Åô„ÇãÊïµ„ÅÆÂ†¥ÊâÄ",
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
              itemList: itemList,
            );
          },
        );
      },
    );
  }

  List<Widget> dialogOptionMonsterMoveField({
    required Map<int, String> location,
    required List<FieldInfo?> fieldInfoCanMove,
    required int fieldNumMe,
    required int monsterIdMe,
    required BattleMapController controller,
    required int? hitPoint,
  }) {
    // ÁßªÂãï„Åô„Çã„Éï„Ç£„Éº„É´„Éâ„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
    final List<Widget> itemListMonsterMove = [];
    // ÁßªÂãïÂèØËÉΩ„Å™„Éï„Ç£„Éº„É´„Éâ„ÅÆ„É´„Éº„Éó
    for (final fieldInfo in fieldInfoCanMove) {
      itemListMonsterMove.insert(
        0,
        SimpleDialogOption(
          child: Text(
            "${location[fieldInfo!.fieldNumber]}",
            style: const TextStyle(
              fontSize: 20,
              color: Colors.white,
            ),
          ),
          onPressed: () async {
            // ÔºíÁîªÈù¢Êàª„Çã
            int count = 0;
            Navigator.popUntil(context, (_) => count++ >= 2);
            controller.monsterMoveField(
              fNumber1: fieldNumMe,
              fNumber2: fieldInfo.fieldNumber,
              monsterId: monsterIdMe,
              hitPoint: hitPoint,
            );
          },
        ),
      );
    }
    return itemListMonsterMove;
  }

  SimpleDialogOption dialogOptionMonsterMove({
    required String skillName,
    required List<Widget> itemList,
  }) {
    return SimpleDialogOption(
      child: Text(
        skillName,
        style: const TextStyle(
          fontSize: 20,
          color: Colors.white,
        ),
      ),
      onPressed: () {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return MultiMenu(
              title: const Text(
                "ÁßªÂãï„Åô„ÇãÂ†¥ÊâÄ",
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
              itemList: itemList,
            );
          },
        );
      },
    );
  }

  // void _addField(BonfireGame game, BattleMapState data) {
  //   final Map<int, dynamic> positionMonsterX = {
  List<Widget> _addField(BattleMapState data, BattleMapController controller) {
    List<Widget> list = [];
    final Map<int, String> location1 = {
      1: "Â∑¶‰∏ã : ‚Üô",
      2: "Âè≥‰∏ã : ‚ÜòÔ∏é",
      3: "Â∑¶‰∏ä : ‚ÜñÔ∏é",
      4: "Âè≥‰∏ä : ‚ÜóÔ∏é",
    };
    final Map<int, String> location2 = {
      5: "Â∑¶‰∏ã : ‚Üô",
      6: "Âè≥‰∏ã : ‚ÜòÔ∏é",
      7: "Â∑¶‰∏ä : ‚ÜñÔ∏é",
      8: "Âè≥‰∏ä : ‚ÜóÔ∏é",
    };
    final Map<int, dynamic> positionMonsterX = {
      1: -0.80,
      2: 0.15, // 3: -0.57,
      3: -0.34, // 4: 0.39,
      4: 0.15, // 5: -0.34,
      5: -0.11, // 6: 0.63,
      6: 0.39,
      7: -0.11,
      8: 0.85,
    };
    final Map<int, dynamic> positionMonsterY = {
      1: 0.36,
      2: 0.57, // 3: 0.04,
      3: 0.10, // 4: 0.25,
      4: 0.19, // 5: -0.28,
      5: -0.22, // 6: -0.07,
      6: -0.13,
      7: -0.60,
      8: -0.39,
    };
    // final Map<int, dynamic> positionPreX = {
    //   1: 0.9,
    //   2: 5.3,
    //   3: 2.0,
    //   4: 6.4,
    //   5: 3.1,
    //   6: 7.5,
    //   7: 4.2,
    //   8: 8.6,
    // };
    // final Map<int, dynamic> positionPreY = {
    //   1: 13.0,
    //   2: 15.0,
    //   3: 10.0,
    //   4: 12.0,
    //   5: 7.0,
    //   6: 9.0,
    //   7: 4.0,
    //   8: 6.0,
    // };

    for (final fieldInfo in data.fieldInfos) {
      if (fieldInfo!.fieldStatus == FieldStatus.monsterSummon ||
          fieldInfo.fieldStatus == FieldStatus.monsterAlreadyActed) {
        final monster =
            data.monsters.firstWhere((e) => e.id == fieldInfo.monsterId);
        // „É¢„É≥„Çπ„Çø„ÉºÂè¨ÂñöÊôÇ„ÅØ„É¢„É≥„Çπ„Çø„Éº„ÇíÊèèÁîª
        // „É¢„É≥„Çπ„Çø„Éº„ÅØ„Éó„É¨„Ç§„É§„Éº„Å®„É©„Ç§„Éê„É´„ÅÆ„ÅßÂàÜ„Åë„Å¶„ÄÅÂêë„ÅçÊõø„Åà„Çã
        final List<Widget> itemList = [];
        // „É¢„É≥„Çπ„Çø„Éº„Çø„ÉÉ„ÉóÊôÇ„ÅÆ„É°„Éã„É•„Éº
        itemList.add(
          dialogOptionMonsterAttack(
            skillName: 'ÊîªÊíÉ1 : ${monster.skill1['name']}',
            itemList: dialogOptionMonsterAttackField(
              location: location2,
              data: data,
              fieldNumMe: fieldInfo.fieldNumber,
              monsterIdMe: fieldInfo.monsterId!,
              controller: controller,
              attackRange: monster.skill1['range'],
            ),
          ),
        );
        if (monster.skill2 != null) {
          itemList.add(
            dialogOptionMonsterAttack(
              skillName: 'ÊîªÊíÉ2 : ${monster.skill2!['name']}',
              itemList: dialogOptionMonsterAttackField(
                location: location2,
                data: data,
                fieldNumMe: fieldInfo.fieldNumber,
                monsterIdMe: fieldInfo.monsterId!,
                controller: controller,
                attackRange: monster.skill2!['range'],
              ),
            ),
          );
        }
        if (monster.skill3 != null) {
          itemList.add(
            dialogOptionMonsterAttack(
              skillName: 'ÊîªÊíÉ3 : ${monster.skill3!['name']}',
              itemList: dialogOptionMonsterAttackField(
                location: location2,
                data: data,
                fieldNumMe: fieldInfo.fieldNumber,
                monsterIdMe: fieldInfo.monsterId!,
                controller: controller,
                attackRange: monster.skill3!['range'],
              ),
            ),
          );
        }
        itemList.add(
          dialogOptionMonsterMove(
            skillName: 'ÁßªÂãï',
            itemList: dialogOptionMonsterMoveField(
              location: location1,
              fieldInfoCanMove: data.fieldInfos
                  .sublist(0, 4)
                  .where(
                      (element) => (element!.fieldStatus == FieldStatus.blank))
                  .toList(),
              fieldNumMe: fieldInfo.fieldNumber,
              monsterIdMe: fieldInfo.monsterId!,
              controller: controller,
              hitPoint: fieldInfo.hitPoint,
            ),
          ),
        );
        itemList.add(SimpleDialogOption(
          onPressed: () => Navigator.pop(context),
          child: const Text(
            "„ÇÇ„Å©„Çã",
            style: TextStyle(
              fontSize: 20,
              color: Colors.white,
            ),
          ),
        ));
        list.add(
          Align(
            alignment: Alignment(positionMonsterX[fieldInfo.fieldNumber],
                positionMonsterY[fieldInfo.fieldNumber]),
            child: SizedBox(
              height: 50,
              child: GestureDetector(
                onTap: () {
                  // Ë°åÂãïÊ∏à„Åø„ÅÆ„É¢„É≥„Çπ„Çø„Éº„ÅØ„Çø„ÉÉ„Éó„Åó„Å¶„ÇÇÂèçÂøú„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
                  // Áõ∏Êâã„É¢„É≥„Çπ„Çø„Éº„ÅÆ„É°„Éã„É•„Éº„ÅØË°®Á§∫„Åï„Çå„Å™„ÅÑ
                  if (fieldInfo.fieldStatus !=
                          FieldStatus.monsterAlreadyActed &&
                      fieldInfo.fieldNumber <= 4) {
                    showDialog(
                      context: context,
                      builder: (BuildContext context) {
                        return MultiMenu(
                          title: Text(
                            monster.monsterName,
                            style: const TextStyle(
                              fontSize: 20,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                          itemList: itemList,
                        );
                      },
                    );
                  }
                },
                child: ColorFiltered(
                  colorFilter: fieldInfo.fieldStatus ==
                          FieldStatus.monsterAlreadyActed
                      ? const ColorFilter.mode(Colors.grey, BlendMode.modulate)
                      : ColorFilter.mode(
                          Colors.white.withOpacity(0), BlendMode.srcATop),
                  child: Image.asset(
                    "assets/images/monsters/${monsterMap[fieldInfo.monsterId]}.png",
                    fit: BoxFit.contain,
                  )
                      .animate(
                        onPlay: (controller) => controller.repeat(),
                      )
                      .shakeY(
                        // delay: 1.seconds,
                        duration: 1.seconds,
                        hz: 1.4,
                        amount: 3,
                      ),
                ),
              ),
            ),
          ),
        );
        list.add(
          Align(
            alignment: Alignment(positionMonsterX[fieldInfo.fieldNumber] - 0.1,
                positionMonsterY[fieldInfo.fieldNumber] + 0.11),
            child: Container(
              decoration: BoxDecoration(
                color: Color.fromARGB(177, 255, 255, 255),
                borderRadius: BorderRadius.all(Radius.circular(10)),
                // border: Border.all(color: Colors.blueGrey),
              ),
              height: 17,
              width: 50,
              child: Text(
                "HP:${fieldInfo.hitPoint.toString()}",
                textAlign: TextAlign.center,
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
            ),
          ),
        );
      } else if (fieldInfo.fieldStatus == FieldStatus.preparation) {
        // Ê∫ñÂÇô‰∏≠„ÅØÊ∫ñÂÇô„Ç®„Éï„Çß„ÇØ„ÉàÔºüÊèèÁîª
        // „Å®„Çä„ÅÇ„Åà„Åö„Éï„Ç£„Éº„É´„Éâ„Å®Âêå„Åò„Å´„Åó„Å¶„Åæ„Åô
        list.add(
          Align(
            alignment: Alignment(positionMonsterX[fieldInfo.fieldNumber],
                positionMonsterY[fieldInfo.fieldNumber]),
            child: Image.asset("assets/images/maps/component/SpriteSheet.png")
                .animate(
                  onPlay: (controller) => controller.repeat(),
                )
                .shakeY(
                  // delay: 1.seconds,
                  duration: 1.seconds,
                  hz: 1.4,
                  amount: 3,
                ),
          ),
        );
      } else if (fieldInfo.fieldStatus == FieldStatus.blank) {
        // ÈùûÂè¨ÂñöÊôÇ„ÅØ„Éï„Ç£„Éº„É´„Éâ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊèèÁîª
        list.add(
          Align(
            alignment: Alignment(positionMonsterX[fieldInfo.fieldNumber],
                positionMonsterY[fieldInfo.fieldNumber]),
            child: SizedBox(
              height: 50,
              child: Image.asset(
                  "assets/images/maps/component/blacknwhite_p=1_s=2.png"),
            ),
          ),
        );
      }
    }
    return list;
  }

  List<GameDecoration> decorations(
      BattleMapState data, BattleMapController controller) {
    // „Ç≠„É£„É©„ÇØ„Çø„ÉºÈÖçÁΩÆ
    final list = [
      BattlePlayer(
        getRelativeTilePosition(3.2, 13.5),
        MultiMenu(
          title: Text(
            "„Éó„É¨„Ç§„É§„ÉºÂêç",
            style: const TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          itemList: [
            SimpleDialogOption(
              child: const Text(
                'Ë°åÂãïÁµÇ‰∫Ü',
                style: TextStyle(
                  fontSize: 20,
                  color: Colors.white,
                ),
              ),
              onPressed: () {
                controller.turnEndPlayer();
                Navigator.pop(context);
              },
            )
          ],
        ),
      ),
      BattleRival(getRelativeTilePosition(6, 4.9)),
      // BattlePlayer(getRelativeTilePosition(6, 10)),
      // BattleRival(getRelativeTilePosition(5, 8)),
    ];

    return list;
  }

  Monster pickMonsterFromId(List<Monster> monsters, int monsterId) {
    return monsters.firstWhere((monster) {
      return monster.id == monsterId;
    });
  }

  static Vector2 getRelativeTilePosition(double x, double y) {
    return Vector2(
      (x * tileSize).toDouble(),
      (y * tileSize).toDouble(),
    );
  }

  List<Widget> _getCardList(
      BattleMapController controller, BattleMapState data) {
    // ÊâãÊú≠ÂèñÂæó
    final List<Widget> cards = [];
    final Map<int, String> location = {
      1: "Â∑¶‰∏ã : ‚Üô",
      2: "Âè≥‰∏ã : ‚ÜòÔ∏é",
      3: "Â∑¶‰∏ä : ‚ÜñÔ∏é",
      4: "Âè≥‰∏ä : ‚ÜóÔ∏é",
    };

    // „É¢„É≥„Çπ„Çø„Éº„ÄÅ„Éû„Ç∏„ÉÉ„ÇØ„Çπ„Éà„É™„Éº„É†„Åã„Çâ„Ç´„Éº„ÉâÊÉÖÂ†±„ÇíË™≠„ÅøÂèñ„Çã

    // „Åì„Åì„Åß„Éâ„É≠„Éº„Åó„Å¶ÊâãÊú≠„ÅÆ„É™„Çπ„Éà„ÇíÊõ¥Êñ∞„Åô„Çã

    // ÊâãÊú≠ÔºëÊûöÔºëÊûö„ÅÆË®≠ÂÆö„É´„Éº„Éó
    for (final handCard in data.handCardsPlayer) {
      // „Ç´„Éº„Éâ„ÇíÂè¨Âñö„Åô„Çã„Éï„Ç£„Éº„É´„Éâ„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
      final List<Widget> itemList = [];
      // ÊâãÊú≠„Åã„Çâ„Éï„Ç£„Éº„É´„Éâ„Å´Âè¨Âñö„Åô„Çã„Åü„ÇÅ„ÅÆÂè¨ÂñöÂÖà„ÅÆ„Éï„Ç£„Éº„É´„ÉâÔºî„Å§„ÅÆ„É´„Éº„Éó
      for (final fieldInfo in data.fieldInfos.sublist(0, 4)) {
        // Á©∫„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅÆ„Åø„É°„Éã„É•„Éº„Å´Ë°®Á§∫
        if (fieldInfo!.fieldStatus == FieldStatus.blank) {
          itemList.insert(
            0,
            SimpleDialogOption(
              child: Text(
                "${location[fieldInfo.fieldNumber]}",
                style: const TextStyle(
                  fontSize: 20,
                  color: Colors.white,
                ),
              ),
              onPressed: () {
                controller.useHandCard(
                  isPlayer: true,
                  fNumber: fieldInfo.fieldNumber,
                  monsterId: handCard.id,
                  hitPoint: handCard.hitPoint,
                );
                // ÔºíÁîªÈù¢Êàª„Çã
                int count = 0;
                Navigator.popUntil(context, (_) => count++ >= 2);
              },
            ),
          );
        }
      }

      cards.add(
        // GestureDetector( Ëâ≤Â§â„Åà„Åü„ÅÑ„ÅÆ„ÅßinkWell„Çí‰ΩøÁî®
        InkWell(
          highlightColor: Colors.pink,
          splashColor: Colors.red,
          focusColor: Colors.yellow,
          hoverColor: Colors.blue,
          onTap: () {
            // Êäº„Åï„Çå„Åü„Çâ„É°„Éã„É•„Éº„Å®„ÄÅ„Ç´„Éº„Éâ„Åå„Å°„Çá„Å£„Å®‰∏ä„Åå„Çä„Åü„ÅÑ
            showDialog(
              context: context,
              builder: (BuildContext context) {
                return SingleMenu(
                  title: Text(
                    handCard.monsterName,
                    style: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  child: const Text(
                    "Âè¨Âñö",
                    style: TextStyle(fontSize: 20),
                  ),
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (BuildContext context) {
                        return MultiMenu(
                          title: const Text(
                            "Âè¨ÂñöÂ†¥ÊâÄ",
                            style: TextStyle(
                              fontSize: 20,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                          itemList: itemList,
                        );
                      },
                    );
                  },
                );
              },
            );
          },
          child: Container(
            clipBehavior: Clip.antiAlias,
            decoration: BoxDecoration(
              borderRadius: const BorderRadius.all(Radius.circular(6.0)),
              border: Border.all(color: Colors.black, width: 2.3),
              // boxShadow: const [cardBoxShadow],
              color: Colors.black26,
            ),
            height: double.infinity,
            width: 62,
            child: Image.asset(
              "assets/images/monsters/${monsterMap[handCard.id]}.png",
              fit: BoxFit.contain,
            ),
            // const Text(
            //   "„Ç´„Éº„Éâ",
            //   style: TextStyle(
            //     backgroundColor: Colors.white,
            //     fontWeight: FontWeight.bold,
            //     fontSize: 10,
            //     color: Colors.black,
            //   ),
            // ),
          ),
        ),
      );
    }
    return cards;
  }
}
